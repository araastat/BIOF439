<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Visualization in different applications</title>
    <meta charset="utf-8" />
    <meta name="author" content="Abhijit Dasgupta, PhD" />
    <script src="biomed_files/header-attrs-2.6/header-attrs.js"></script>
    <link href="biomed_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="robot.css" type="text/css" />
    <link rel="stylesheet" href="robot-fonts.css" type="text/css" />
    <link rel="stylesheet" href="sfah.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Visualization in different applications
### Abhijit Dasgupta, PhD

---




layout: true

&lt;div class="my-header"&gt;
&lt;span&gt;BIOF 439: Data Visualization using R&lt;/span&gt;&lt;/div&gt;

---

## Goals

1. Visualization in biomedical applications and models
1. Visualizing spatial data using maps
1. Bioinformatics

---
class: middle, inverse

# Biomedical applications

---
class: middle

# Survival analysis

---

## Survival analysis

Survival analysis is the analysis of time-to-event data. In biomedical research, *event* can mean

1. death
1. recurrence or relapse (cancer, infection)
1. equipment failure (pacemakers, orthopedic implants)

--

You need two pieces of information: 
1. the time of the event or the time you last saw the subject, and 
1. the status (dead/alive) the last time you saw the subject. If subject is alive, you call that observation _censored_, since you didn't observe the subject long enough to see the event happen.
---

## Survival analysis

The basic graphical tool in survival analysis is the _Kaplan-Meier curve_, which shows the 
proportion of subjects **still surviving** at any given time, with 100% alive at time 0. 

The Kaplan-Meier curve is computed using the function `survival::survfit` and uses the
same formula interface as usual models, with one little quirk.


```r
library(survival)
brca &lt;- readxl::read_excel('data/BreastCancer_Clinical.xlsx', .name_repair = 'universal')
fit &lt;- survfit(Surv(OS.Time, OS.event) ~ PR.Status, data = brca)
```

We have a composite dependent variable, comprising both the time and status of each event. It is 
encapsulated in the function `Surv` (note capitalization)

---

## Kaplan-Meier curve

.left-column70[
![](biomed_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;
]
.right-column70[
+ Small ticks are times when subjects are censored
+ The log-rank test tests if the stratified curves are statistically different
+ The risk table gives the number still alive at different times.
]
---

## Kaplan-Meier curve

The plot is generated by the following code:


```r
library(survminer)
(plt &lt;- ggsurvplot(fit, pval=TRUE, pval.method = TRUE, risk.table=TRUE,
                   legend.labs = c('PR-','PR+'),
                   xlab = 'Time (days)'))
```

+ The actual plot can be accessed using `plt$plot` and is a regular **ggplot2** object
+ The table can be accessed using `plt$table` and is _also_ a **ggplot2** object

There is a lot of customization of these plots that are possible. See 
[https://rpkgs.datanovia.com/survminer/index.html](https://rpkgs.datanovia.com/survminer/index.html) for
tutorials and details.

---
class: middle

# Regression results

---

## Displaying the results of a regression model

We're used to seeing the results of a regression analysis in tables, but graphically displaying them
may make them easier to understand. 

We'll use a toy example using the `mpg` data.

We fit a linear regression model using 


```r
mpg &lt;- mpg %&gt;% 
  mutate(year = as.factor(year)) %&gt;% 
  mutate(trans = str_extract(trans, '[:alnum:]+')) %&gt;% 
  mutate(cyl = as.factor(cyl))
fit &lt;- lm(cty ~ year + trans + cyl + drv + class, data=mpg)
```

This models city mpg against year, type of transmission, number of cylinders, type of drive, and class of car.

---

## Displaying the results of a regression model

As a table, these results look like 

.left-column70[

```r
knitr::kable(broom::tidy(fit))
```



|term            |   estimate| std.error|   statistic|   p.value|
|:---------------|----------:|---------:|-----------:|---------:|
|(Intercept)     | 20.5622426| 1.1227750|  18.3137694| 0.0000000|
|year2008        |  0.4624090| 0.2712424|   1.7047815| 0.0896468|
|transmanual     |  0.4024746| 0.3106162|   1.2957299| 0.1964264|
|cyl5            | -2.1058003| 1.0607113|  -1.9852718| 0.0483563|
|cyl6            | -3.4162456| 0.3620780|  -9.4351106| 0.0000000|
|cyl8            | -5.5938201| 0.4951472| -11.2972877| 0.0000000|
|drvf            |  2.5030933| 0.4872506|   5.1371787| 0.0000006|
|drvr            | -0.0873527| 0.5793938|  -0.1507656| 0.8802988|
|classcompact    | -1.6774636| 1.1124558|  -1.5078924| 0.1330167|
|classmidsize    | -2.2914265| 1.1438440|  -2.0032683| 0.0463754|
|classminivan    | -4.3516621| 1.2936355|  -3.3639014| 0.0009065|
|classpickup     | -3.5335839| 1.1133642|  -3.1737898| 0.0017198|
|classsubcompact | -0.5689003| 1.0690946|  -0.5321328| 0.5951710|
|classsuv        | -3.0282240| 1.0504330|  -2.8828341| 0.0043320|
]
.right-column70[
Obviously this needs cleaning up

We'd fix the terms, and reduce the number of decimal places to 2

The point is, it's relatively hard to understand the relative effects of different levels.
]

---

## Displaying the results of a regression model

As a figure, it's probably a bit better

.left-column70[

```r
results = broom::tidy(fit) %&gt;% filter(term !="(Intercept)")
ggplot(results)+
  geom_pointrange(aes(x=term, y=estimate, 
                      ymin = estimate-2*std.error, ymax=estimate+2*std.error))+
  geom_hline(yintercept=0, linetype=2) + 
  coord_flip() + 
  theme_439
```

![](biomed_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;
]
.right-column70[
We plot the estimate and 95% confidence interval for each term

Provide reference line of 0

.heatinline[Can see increasing and decreasing patterns within variable levels]

We'll work on cleaning this picture up in a tutorial
]

---
class: inverse

## A learning note

You've been gaining some experience in creating graphics. 

I'll increasingly be providing complete code, and will expect you to work on parsing 
that code and understanding what the different parts are doing

One of the nice things about learning an open-source language is that there are plenty of
examples out there, and you're allowed (for the most part) to copy others' code. So developing
the skill of understanding other people's code is really useful and somewhat important.

.saltinline[Reach out to me if it really feels mysterious and arcane. I'm not teaching mystical arts here.]

---

## Logistic regression

We'll use the `PimaIndianDiabetes2` data from the **mlbench** package


```r
library(mlbench); data("PimaIndiansDiabetes2") # 2 commands separated by ;
fit_logistic &lt;- glm(diabetes ~ pregnant + pressure + triceps + mass, 
                    data = PimaIndiansDiabetes2, 
                    family='binomial') # This option makes this logistic regression
```

The unifying step to displaying the results of most regression modeling is `broom::tidy`. We'll transform the 
results a bit, since logistic regression provides log-odds ratios and we will display the odds ratios.


```r
results &lt;- broom::tidy(fit_logistic)
results &lt;- results %&gt;% 
  mutate(OR = exp(estimate),
         LCB = exp(estimate - 2*std.error),
         UCB = exp(estimate + 2*std.error)) %&gt;% 
  filter(term != '(Intercept)')
```

---

## Logistic regression

.left-column70[

```r
ggplot(results)+
  geom_pointrange(aes(x = term, y = OR, ymin = LCB, ymax = UCB))+
  geom_hline(yintercept = 1, linetype=2)+
  coord_flip()
```

![](biomed_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;
]
.right-column70[
The graph makes it clear that number of pregnancies and body mass significantly influence the odds of being diabetic, but blood pressure and tricep size do not
]

---

## Cox proportional hazards regression

For survival data, Cox regression is typically used to model the *hazard rate*, i.e. the instantaneous
risk of having an event. 

We'll use the breast cancer dataset to do this, after some data munging


```r
library(survival)
brca1 &lt;- brca %&gt;% 
  mutate(ER.Status = ifelse(ER.Status == 'Indeterminate', NA, ER.Status),
         HER2.Final.Status = ifelse(HER2.Final.Status=='Equivocal', NA, HER2.Final.Status))
fit_cox &lt;- coxph(Surv(OS.Time,OS.event) ~ ER.Status + PR.Status + HER2.Final.Status, data=brca1)
(results &lt;- broom::tidy(fit_cox))
```

```
  # A tibble: 3 x 5
    term                      estimate std.error statistic p.value
    &lt;chr&gt;                        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
  1 ER.StatusPositive          -0.0428     0.909   -0.0471   0.962
  2 PR.StatusPositive          -1.00       0.923   -1.08     0.278
  3 HER2.Final.StatusPositive  -1.55       1.12    -1.39     0.166
```

Notice that a Cox regression does not have an intercept term
---

## Cox regression

.left-column70[

```r
results &lt;- results %&gt;% 
  mutate(HR = exp(estimate),
         LCB = exp(estimate - 2*std.error),
         UCB = exp(estimate + 2*std.error))
ggplot(results)+
  geom_pointrange(aes(x = term, y = HR, 
                      ymin = LCB, ymax = UCB)) +
  geom_hline(yintercept = 1, linetype=2)+
  coord_flip()+
  theme_439
```

![](biomed_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;

]
.right-column70[
These results may seem counter-intuitive

One may need to do some model building to see what model fits the data well, i.e.
what variables and transformed variables should be included in the model.
]

---

## Creating a function for these plots

We've basically used the same code to create the graphs in all three cases, albeit with
some modest data transformations. 

A general rule is that if you're using the same code more than twice, you should probably make it into a 
function, so you avoid copy-and-paste of code and the mistakes that engenders


```r
plt_reg_results &lt;- function(results, reflevel=0){
  require(ggplot2)
  plt &lt;- ggplot(results)+
    geom_pointrange(aes(x = term, y = estimate, 
                        ymin = LCB, ymax = UCB))+
    geom_hline(yintercept = reflevel)+
    coord_flip()
  return(plt)
}
```

You should document what format `results` should be in, and what `reflevel` means using comments

With such a function, you might need to do a bit more data munging, but creating the plots becomes a unified process.

---

## Creating a function for these plots

.pull-left[

```r
broom::tidy(fit) %&gt;% 
  mutate(LCB = estimate - 2*std.error,
         UCB = estimate + 2*std.error) %&gt;% 
  filter(term!='(Intercept)') %&gt;% 
  plt_reg_results()
```

![](biomed_files/figure-html/unnamed-chunk-13-1.png)&lt;!-- --&gt;

]
.pull-right[

```r
broom::tidy(fit_logistic) %&gt;% 
  mutate(LCB = exp(estimate - 2*std.error),
         UCB = exp(estimate + 2*std.error),
         estimate = exp(estimate)) %&gt;% 
  filter(term != '(Intercept)') %&gt;% 
  plt_reg_results(reflevel=1)
```

![](biomed_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;

]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="../js/macros.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightLanguage": "R",
"countIncrementalSlides": false,
"highlightStyle": "docco",
"highlightLines": true,
"slideNumberFormat": "%current%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
